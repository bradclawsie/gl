# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
# CLAUDE.md

Behavioral guidelines to reduce common LLM coding mistakes. Merge with project-specific instructions as needed.

**Tradeoff:** These guidelines bias toward caution over speed. For trivial tasks, use judgment.

## 1. Think Before Coding

**Don't assume. Don't hide confusion. Surface tradeoffs.**

Before implementing:
- State your assumptions explicitly. If uncertain, ask.
- If multiple interpretations exist, present them - don't pick silently.
- If a simpler approach exists, say so. Push back when warranted.
- If something is unclear, stop. Name what's confusing. Ask.

## 2. Simplicity First

**Minimum code that solves the problem. Nothing speculative.**

- No features beyond what was asked.
- No abstractions for single-use code.
- No "flexibility" or "configurability" that wasn't requested.
- No error handling for impossible scenarios.
- If you write 200 lines and it could be 50, rewrite it.

Ask yourself: "Would a senior engineer say this is overcomplicated?" If yes, simplify.

## 3. Surgical Changes

**Touch only what you must. Clean up only your own mess.**

When editing existing code:
- Don't "improve" adjacent code, comments, or formatting.
- Don't refactor things that aren't broken.
- Match existing style, even if you'd do it differently.
- If you notice unrelated dead code, mention it - don't delete it.

When your changes create orphans:
- Remove imports/variables/functions that YOUR changes made unused.
- Don't remove pre-existing dead code unless asked.

The test: Every changed line should trace directly to the user's request.

## 4. Goal-Driven Execution

**Define success criteria. Loop until verified.**

Transform tasks into verifiable goals:
- "Add validation" → "Write tests for invalid inputs, then make them pass"
- "Fix the bug" → "Write a test that reproduces it, then make it pass"
- "Refactor X" → "Ensure tests pass before and after"

For multi-step tasks, state a brief plan:
```
1. [Step] → verify: [check]
2. [Step] → verify: [check]
3. [Step] → verify: [check]
```

Strong success criteria let you loop independently. Weak criteria ("make it work") require constant clarification.

---

**These guidelines are working if:** fewer unnecessary changes in diffs, fewer rewrites due to overcomplication, and clarifying questions come before implementation rather than after mistakes.

## Project Overview

GrokLOC (`gl`) is a Perl 5.42+ web application providing organization, user, and repository management with field-level encryption, Ed25519 key management, and comprehensive audit logging. It uses SQLite, Plack/PSGI, and the Marlin object system with Type::Tiny for strict type validation.

## Commands

All commands use `just` (command runner). The justfile sets up `PERL5LIB`, `PATH`, `SCHEMA`, and other environment variables automatically.

| Command | Purpose |
|---------|---------|
| `just test` | Run all tests with yath (Test2::Harness) |
| `just yath t/02-user.t` | Run a single test file |
| `just check` | Perl syntax check on all .pm, .psgi, .t files |
| `just critic` | Run Perl::Critic (severity 1) |
| `just tidy` | Format with perltidy |
| `just deps` | Install Carton dependencies |
| `just development-psgi` | Run dev server (file-based SQLite) |
| `just test-psgi` | Run test server (in-memory SQLite) |

A good combination to validate changes is: `just check critic test`.

To tidy up the code and validate changes: `just tidy check critic test`.

## Architecture

### Object System

Models use **Marlin** (a Perl role/object builder with Type::Tiny integration). Marlin attribute sigils control access: `==` for read-only setters, `!` for required-at-construction, combined as `==!`. See `GL::Model` for the base role consumed by `GL::User` and `GL::Org` via `-with`.

### Type Safety

- `GL::Type` defines custom types: `Digest`, `Ed25519Public`, `Ed25519Private`, `IV`, `Key`, `Password`, `Role`, `Status`, `DB`
- `GL::Attribute` provides role/status constants (`$ROLE_TEST`, `$STATUS_ACTIVE`, etc.)
- Method signatures enforced via `Type::Params::signature_for`

### Database

- SQLite with `DBIx::Connector` (connection pooling, `fixup` mode for auto-reconnect)
- Schema in `sql/schema.sql` — tables: `org`, `user`, `repository`, `audit_log`
- UUIDs generated by a custom SQLite `uuid()` function registered at connection time
- All tables have trigger-managed `ctime`, `mtime`, and `signature` (UUID) columns
- `AFTER UPDATE` triggers write to `audit_log` for owner/status changes
- Write operations use `RETURNING` clauses to capture generated values

### Encryption Pattern

Sensitive user fields (`email`, `display_name`, `ed25519_public`) are encrypted with AES-GCM before storage. Each user has a `key_version` UUID that maps to an encryption key via a `$get_key` callback (CodeRef). SHA256 digest columns stored alongside encrypted fields for lookup without decryption. Users can be re-encrypted with a new key version via `reencrypt`.

### Runtime Environments

- `GL::Runtime::Test` — in-memory SQLite, used by tests
- `GL::Runtime::Development` — file-based SQLite at `$DB_FILE`
- Both register the custom `uuid()` SQL function and load `sql/schema.sql`

### Test Conventions

- Test framework: `Test2::V0` with `Test2::Harness` (yath)
- Files prefixed `01-` for unit tests (crypto, types, runtime), `02-` for model integration tests
- Tests instantiate `GL::Runtime::Test` for an isolated in-memory database
- Use `lives`/`dies` blocks and subtests for assertion grouping
- `GL::User->random(...)` and `GL::Org->random(...)` create test fixtures with randomized data

### Code Quality

- Perl::Critic at severity 1 (strictest) with project-specific exceptions in `.perlcritic`
- `.perltidyrc` for formatting
